/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "pubsub.h"
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
#include <cstdlib>
#include <cstring>
#include <string>
#include <iostream>
#include <atomic>
#include <chrono>

static const char *reg_server_name = "dio.cs.umn.edu";
static const int reg_server_port = 5105;

static std::atomic_ulong num_articles_received(0);
static std::atomic_ulong num_articles_published(0);

// Client simulation parameters
static const int num_subs = 10;
static const int num_pubs = 10;

typedef struct {
  struct sockaddr_in addr;
  int sock_fd;
} listen_arg;

void get_list() {
  int reg_sock;
  if ((reg_sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    perror("cannot create socket");
    exit(1);
  }

  struct hostent *hp = gethostbyname(reg_server_name);
  if (!hp) {
    fprintf(stderr, "could not obtain server address (%s)\n", reg_server_name);
    return;
  }

  struct sockaddr_in server_addr;
  memset((char *)&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(reg_server_port);
  memcpy((void *)&server_addr.sin_addr, hp->h_addr_list[0], hp->h_length);

  socklen_t reg_len = sizeof(server_addr);
  if (connect(reg_sock, (struct sockaddr *)&server_addr, reg_len) < 0) {
    perror("connect");
    exit(1);
  }

  struct sockaddr_in client_reg_addr;
  socklen_t client_reg_len = sizeof(client_reg_addr);
  if (getsockname(reg_sock, (struct sockaddr *)&client_reg_addr,
                  &client_reg_len) < 0) {
    perror("getsockname failed");
    exit(1);
  }

  char *client_reg_ip = inet_ntoa(client_reg_addr.sin_addr);
  int client_reg_port = ntohs(client_reg_addr.sin_port);

  char message[MAXSTRING];
  sprintf(message, "GetList;RPC;%s;%d", client_reg_ip, client_reg_port);

  sendto(reg_sock, message, sizeof(message), 0, (struct sockaddr *)&server_addr,
         sizeof(server_addr));

  char list[1024];
  recvfrom(reg_sock, list, sizeof(list), 0, NULL, NULL);
  printf("%s\n", list);

  close(reg_sock);
}

void *listen_for_articles(void *arg) {
  listen_arg *l_arg = (listen_arg *)arg;
  // printf("Listening for new articles on port %d through fd %d\n",
  //        ntohs(l_arg->addr.sin_port), l_arg->sock_fd);
  char buf[MAXSTRING];
  socklen_t addrlen = sizeof(l_arg->addr);
  while (1) {
    int recvlen = recvfrom(l_arg->sock_fd, buf, MAXSTRING, 0,
                           (struct sockaddr *)&l_arg->addr, &addrlen);
    if (recvlen > 0) {
      buf[recvlen] = 0;
      printf("\r*** New article: \"%s\"\n", buf);
      num_articles_received++;
    }
  }
}

void *ping(void *arg) {
  CLIENT *clnt;
  bool_t *result;
  char *host = (char *)arg;
#ifndef DEBUG
  clnt = clnt_create(host, PUBSUB_PROG, PUBSUB_VERSION, "udp");
  if (clnt == NULL) {
    clnt_pcreateerror(host);
    exit(1);
  }
#endif
  while (1) {
    sleep(5);
    result = ping_1(clnt);
    if (result == (bool_t *)NULL) {
      clnt_perror(clnt, "Connection to server lost");
      exit(1);
    }
  }
}

void setup_client_connection(char *host, int &sock_fd,
                             struct sockaddr_in &client_addr) {
  if ((sock_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    perror("cannot create socket");
    exit(1);
  }

  struct hostent *hp = gethostbyname(host);
  if (!hp) {
    fprintf(stderr, "could not obtain server address (%s)\n", host);
    exit(1);
  }

  struct sockaddr_in server_addr;

  memset((char *)&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(0);

  memcpy((void *)&server_addr.sin_addr, hp->h_addr_list[0], hp->h_length);

  socklen_t len = sizeof(server_addr);
  if (connect(sock_fd, (struct sockaddr *)&server_addr, len) < 0) {
    perror("connect");
    exit(1);
  }

  socklen_t alen = sizeof(client_addr);
  if (getsockname(sock_fd, (struct sockaddr *)&client_addr, &alen) < 0) {
    perror("getsockname failed");
    exit(1);
  }
}

void pubsub_prog_1(char *host) {
  CLIENT *clnt;
  bool_t *result;

#ifndef DEBUG
  clnt = clnt_create(host, PUBSUB_PROG, PUBSUB_VERSION, "udp");
  if (clnt == NULL) {
    clnt_pcreateerror(host);
    exit(1);
  }
#endif /* DEBUG */

  // result = joinserver_1(client_ip, PUBSUB_PROG, PUBSUB_VERSION, clnt);
  // if (result == (bool_t *)NULL) {
  //   clnt_perror(clnt, "call failed");
  // }

  // result = leaveserver_1(client_ip, PUBSUB_PROG, PUBSUB_VERSION, clnt);
  // if (result == (bool_t *)NULL) {
  //   clnt_perror(clnt, "call failed");
  // }

  int sock_fd;
  struct sockaddr_in client_addr;
  setup_client_connection(host, sock_fd, client_addr);

  int ip = ntohl(client_addr.sin_addr.s_addr);
  char client_ip[INET_ADDRSTRLEN];
  inet_ntop(AF_INET, &ip, client_ip, INET_ADDRSTRLEN);
  int client_port = ntohs(client_addr.sin_port);

  listen_arg listen = {client_addr, sock_fd};

  pthread_t listen_thread, ping_thread;
  if (pthread_create(&listen_thread, NULL, listen_for_articles,
                     (void *)&listen)) {
    fprintf(stderr, "Error creating listening thread\n");
    exit(1);
  }

  if (pthread_create(&ping_thread, NULL, ping, (void *)host)) {
    fprintf(stderr, "Error creating pinging thread\n");
    exit(1);
  }

  result = join_1(client_ip, client_port, clnt);
  if (result == (bool_t *)NULL) {
    clnt_perror(clnt, "call failed");
  } else if (*result) {
    fprintf(stderr, "Error joining %s\n", host);
  } else {
    printf("Successfully joined %s as %s:%d\n", host, client_ip, client_port);
  }

  int quit = 0;
  do {
    char *action;
    char *message;
    printf("pubsub> ");
    char line[MAXSTRING + 20];
    fgets(line, MAXSTRING + 20, stdin);
    if (*line == '\n') continue;
    action = strtok_r(line, " ", &message);
    message[strlen(message) - 1] = 0;
    if (!strncmp(action, "q", 1) || !strncmp(action, "exit", 4) ||
        !strncmp(action, "quit", 4) || !strncmp(action, "Q", 1)) {
      quit = 1;
    } else if (!strncmp(action, "publish", 7)) {
      result = publish_1(message, client_ip, client_port, clnt);
      if (result == (bool_t *)NULL) {
        clnt_perror(clnt, "call failed");
      } else if (*result) {
        fprintf(stderr, "Error publishing\n");
      }
    } else if (!strncmp(action, "subscribe", 9)) {
      result = subscribe_1(client_ip, client_port, message, clnt);
      if (result == (bool_t *)NULL) {
        clnt_perror(clnt, "call failed");
      } else if (*result) {
        fprintf(stderr, "Error subscribing\n");
      }
    } else if (!strncmp(action, "unsubscribe", 11)) {
      result = unsubscribe_1(client_ip, client_port, message, clnt);
      if (result == (bool_t *)NULL) {
        clnt_perror(clnt, "call failed");
      } else if (*result) {
        fprintf(stderr, "Error unsubscribing\n");
      }
    } else if (!strncmp(action, "get_list", 8)) {
      get_list();
    } else {
      fprintf(stderr, "Command not supported\n");
    }
  } while (!quit);

  result = leave_1(client_ip, client_port, clnt);
  if (result == (bool_t *)NULL) {
    clnt_perror(clnt, "call failed");
  } else if (*result) {
    fprintf(stderr, "Error leaving %s\n", host);
  }

  pthread_cancel(listen_thread);
  pthread_cancel(ping_thread);

  close(sock_fd);

  pthread_join(listen_thread, NULL);
  pthread_join(ping_thread, NULL);

  // result =
  //     publishserver_1(publishserver_1_Article, client_ip, client_port,
  //     clnt);
  // if (result == (bool_t *)NULL) {
  //   clnt_perror(clnt, "call failed");
  // }

#ifndef DEBUG
  clnt_destroy(clnt);
#endif /* DEBUG */
}

void *pubsub_test(void *arg) {
  char *host = (char *)arg;
  CLIENT *clnt;
  bool_t *result;

#ifndef DEBUG
  clnt = clnt_create(host, PUBSUB_PROG, PUBSUB_VERSION, "udp");
  if (clnt == NULL) {
    clnt_pcreateerror(host);
    exit(1);
  }
#endif /* DEBUG */

  int sock_fd;
  struct sockaddr_in client_addr;
  setup_client_connection(host, sock_fd, client_addr);

  int ip = ntohl(client_addr.sin_addr.s_addr);
  char client_ip[INET_ADDRSTRLEN];
  inet_ntop(AF_INET, &ip, client_ip, INET_ADDRSTRLEN);
  int client_port = ntohs(client_addr.sin_port);

  listen_arg listen = {client_addr, sock_fd};

  pthread_t listen_thread, ping_thread;
  if (pthread_create(&listen_thread, NULL, listen_for_articles,
                     (void *)&listen)) {
    fprintf(stderr, "Error creating listening thread\n");
    exit(1);
  }

  if (pthread_create(&ping_thread, NULL, ping, (void *)host)) {
    fprintf(stderr, "Error creating pinging thread\n");
    exit(1);
  }

  long unsigned error_count = 0;

  result = join_1(client_ip, client_port, clnt);
  if (result == (bool_t *)NULL) {
    clnt_perror(clnt, "call failed");
  } else if (*result) {
    return (void *)1;
  }

  // Generate random subscriptions
  static char *blank = "";
  static char *types[] = {"Sports",   "Lifestyle",  "Entertainment",
                          "Business", "Technology", "Science",
                          "Politics", "Health"};
  for (int i = 0; i < num_subs; i++) {
    char sub[MAXSTRING];
    char *type, orig, org;
    unsigned fields = (rand() % 7) + 1;
    bool has_type = (fields & 0x4) >> 2;
    bool has_orig = (fields & 0x2) >> 1;
    bool has_org = fields & 0x1;
    type = has_type ? types[rand() % 8] : blank;
    orig = has_orig ? (char)(rand() % 26 + 65) : 0;
    org = has_org ? (char)(rand() % 26 + 65) : 0;

    // Bite me
    switch (fields) {
      case 1:
        sprintf(sub, ";;%c;", org);
        break;
      case 2:
        sprintf(sub, ";%c;;", orig);
        break;
      case 3:
        sprintf(sub, ";%c;%c;", orig, org);
        break;
      case 4:
        sprintf(sub, "%s;;;", type);
        break;
      case 5:
        sprintf(sub, "%s;;%c;", type, org);
        break;
      case 6:
        sprintf(sub, "%s;%c;;", type, orig);
        break;
      case 7:
        sprintf(sub, "%s;%c;%c;", type, orig, org);
        break;
    }

    result = subscribe_1(client_ip, client_port, sub, clnt);
    if (result == (bool_t *)NULL) {
      clnt_perror(clnt, "call failed");
      break;
    } else if (*result) {
      error_count++;
    }
  }

  for (int i = 0; i < num_pubs; i++) {
    char sub[MAXSTRING];
    char *type, orig, org, *content = "content";
    unsigned fields = (rand() % 7) + 1;
    bool has_type = (fields & 0x4) >> 2;
    bool has_orig = (fields & 0x2) >> 1;
    bool has_org = fields & 0x1;
    type = has_type ? types[rand() % 8] : blank;
    orig = has_orig ? (char)(rand() % 26 + 65) : 0;
    org = has_org ? (char)(rand() % 26 + 65) : 0;

    // Bite me
    switch (fields) {
      case 1:
        sprintf(sub, ";;%c;%s", org, content);
        break;
      case 2:
        sprintf(sub, ";%c;;%s", orig, content);
        break;
      case 3:
        sprintf(sub, ";%c;%c;%s", orig, org, content);
        break;
      case 4:
        sprintf(sub, "%s;;;%s", type, content);
        break;
      case 5:
        sprintf(sub, "%s;;%c;%s", type, org, content);
        break;
      case 6:
        sprintf(sub, "%s;%c;;%s", type, orig, content);
        break;
      case 7:
        sprintf(sub, "%s;%c;%c;%s", type, orig, org, content);
        break;
    }

    result = publish_1(sub, client_ip, client_port, clnt);
    if (result == (bool_t *)NULL) {
      clnt_perror(clnt, "call failed");
      break;
    } else if (*result) {
      error_count++;
    } else {
      num_articles_published++;
    }
  }

  result = leave_1(client_ip, client_port, clnt);
  if (result == (bool_t *)NULL) {
    clnt_perror(clnt, "call failed");
  } else if (*result) {
    error_count++;
  }

  pthread_cancel(listen_thread);
  pthread_cancel(ping_thread);

  close(sock_fd);

  pthread_join(listen_thread, NULL);
  pthread_join(ping_thread, NULL);

#ifndef DEBUG
  clnt_destroy(clnt);
#endif /* DEBUG */
  return (void *)error_count;
}

int main(int argc, char *argv[]) {
  if (argc < 2) {
    printf("usage: %s server_host\n", argv[0]);
    exit(1);
  }

  char *host = argv[1];

  if (argc > 2 && !strncmp(argv[2], "test", 4)) {
    pthread_t threads[MAXCLIENT];
    long unsigned error_counts[MAXCLIENT];
    srand(time(NULL));
    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < MAXCLIENT; i++) {
      if (pthread_create(&threads[i], NULL, pubsub_test, host)) {
        fprintf(stderr, "Error creating client thread\n");
        exit(1);
      }
    }
    for (int i = 0; i < MAXCLIENT; i++) {
      pthread_join(threads[i], (void **)&error_counts[i]);
    }
    auto end = std::chrono::high_resolution_clock::now();

    long unsigned total_errors = 0;
    for (int i = 0; i < MAXCLIENT; i++) {
      total_errors += error_counts[i];
    }

    printf("%d clients with up to %d subscriptions simulated\n", MAXCLIENT,
           num_subs);
    printf("%lu articles published out of %d attempts\n",
           num_articles_published.load(std::memory_order_relaxed),
           MAXCLIENT * num_pubs);
    printf("%lu articles sent\n",
           num_articles_received.load(std::memory_order_relaxed));
    printf("Time: %.3f seconds\n",
           std::chrono::duration_cast<std::chrono::milliseconds>(end - start)
                   .count() /
               1000.);
    printf("Errors: %lu\n", total_errors);
  } else {
    pubsub_prog_1(host);
  }

  exit(0);
}
